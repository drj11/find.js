#!/usr/bin/env coffee

fs = require 'fs'
util = require 'util'

async = require 'async'

OUT = process.stdout

evalExpression = (file, environment, node, cb) ->
  """*file* is an object with a .name property and a
  .stat method.
  *node* is a compiled node object, as returned by
  compileExpression."""
  switch node.op
    when '-depth'
      return cb true
    when '-print'
      OUT.write file.name + '\n'
      return cb true
    when '-size'
      return file.stat (err, stat) ->
        x = node.arg
        s = stat.size
        if /c$/.test x
          # Removing trailing 'c'.
          x = x[..-2]
        else
          # Measure in blocks (rounded up).
          s = Math.ceil(s / 512)
        if x[0] == '+'
          cb(s > +x)
        else if x[0] == '-'
          cb(s < -x)
        else
          cb(s == +x)
    when '-type'
      return file.stat (err, stat) ->
        if node.arg == 'f'
          v = stat.isFile()
        if node.arg == 'd'
          v = stat.isDirectory()
        if node.arg == 'l'
          v = stat.isSymbolicLink()
        if node.arg == 'p'
          v = stat.isFIFO()
        return cb v
    when '-a'
      return evalExpression file, environment, node.arg[0], (res) ->
        if not res
          cb res
        else
          evalExpression file, environment, node.arg[1], cb
    when '-o'
      return evalExpression file, environment, node.arg[0], (res) ->
        if res
          cb res
        else
          evalExpression file, environment, node.arg[1], cb
  console.warn "Unknown expression", node
  return cb()

class File
  constructor: (@name) ->

  stat: (cb) ->
    if @_stat
      return cb null, @_stat
    # :todo: stat vs lstat should be under control of -H and
    # -L options.
    fs.lstat @name, (err, stat) =>
      if not err
        @_stat = stat
      cb err, stat

# Not really a compiler, but there are some source to source
# transformations we do to add an implicit -print.
compileExpression = (tokenList) ->
  environment = {}
  if tokenList.length == 0
    tokenList.push '-print'
  if '-print' not in tokenList and '-exec' not in tokenList and '-ok' not in tokenList
    tokenList = ['('].concat tokenList, [')', '-print']
  # Set .depth when -depth is used.
  # :todo: ideally we'd remove these '-depth' tokens, but we
  # can't do that easily as it might upset the syntax (for
  # example, 'find . -type -a -depth' is valid)
  environment.depth = ('-depth' in tokenList)
  [parsed, tail] = parseExpression tokenList
  if /parse/.test process.env.FIND_DEBUG
    console.warn util.inspect parsed, depth: Infinity
  return { environment: environment, tree: parsed }

# operator precedence table
PREC =
  o: 4
  a: 8

parsePrec = (expression, precedence) ->
  if /descent/.test process.env.FIND_DEBUG
    console.warn expression
  if expression[0] == '('
    [L, tail] = parseExpression expression[1..]
    if tail[0] != ')'
      throw 'mismatched paren ' + expression + tail
    tail.shift()
  else if expression[0] in ['-name', '-path', '-perm',
    '-type', '-links', '-user', '-group',
    '-size', '-atime', '-ctime', '-mtime',
    '-newer']
    # All the 1-ary operators.
    L = { op: expression[0], arg: expression[1] }
    tail = expression[2..]
  else if expression[0] in ['-nouser', '-nogroup',
    '-xdev', '-prune', '-print', '-depth']
    # All the 0-ary operators.
    L = { op: expression[0] }
    tail = expression[1..]
  reduceTail L, tail, precedence

reduceTail = (L, tail, precedence) ->
  if tail.length == 0
    return [L, tail]
  if tail[0] == ')'
    return [L, tail]
  if tail[0] == '-o'
    if precedence <= PREC.o
      [R, tail] = parsePrec tail[1..], PREC.o
      node = { op: '-o', arg: [L, R] }
      return reduceTail node, tail, precedence
    else
      return [L, tail]
  if tail[0] == '-a'
    # -a is optional between expressions.
    tail = tail[1..]
  if precedence <= PREC.a
    [R, tail] = parsePrec tail, PREC.a
    node = { op: '-a', arg: [L, R] }
    return reduceTail node, tail, precedence
  else
    return [L, tail]

parseExpression = (exp) ->
  parsePrec exp, 0
  

one = (file, expression, cb) ->
  evalExpression file, expression.environment, expression.tree, ->
    file.stat (err, st) ->
      if err
        throw err
      if st.isDirectory()
        mapdir file, expression, cb
      else
        cb()

oneDepth = (file, expression, cb) ->
  file.stat (err, st) ->
    if err
      throw err
    if st.isDirectory()
      mapdir file, expression, ->
        evalExpression file, expression.environment, expression.tree, cb
    else
      evalExpression file, expression.environment, expression.tree, cb

mapdir = (file, expression, done) ->
  fs.readdir file.name, (err, names) ->
    if err
      throw err
    async.each names, (name, cb) ->
      newname = pathjoin file.name, name
      one (new File(newname)), expression, cb
    , done

pathjoin = (dir, name) ->
  if /\/$/.test dir
    return dir + name
  else
    return dir + "/" + name

parseArguments = (args) ->
  files = []
  expression = []
  for v,i in args
    # The first argument that is '!' or ')' or starts with a '-'
    # marks the start of the expression.
    if /^(-|!$|\($)/.test v
      expression = args[i..]
      break
    else
      files.push v
  return [files, expression]

[files, expression] = parseArguments process.argv[2..]

compiled = compileExpression expression
if compiled.environment.depth
  one = oneDepth

async.each files, (name, cb) ->
  one (new File(name)), compiled, cb
, process.exit
