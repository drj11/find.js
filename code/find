#!/usr/bin/env coffee

fs = require 'fs'
util = require 'util'

async = require 'async'

OUT = process.stdout

evalExpression = (name, environment, node, cb) ->
  """*node* is a compiled node object, as returned by
  compileExpression."""
  switch node.op
    when '-print'
      OUT.write name + '\n'
      return cb true
    when '-size'
      return fs.stat name, (err, stat) ->
        s = Math.ceil(stat.size / 512)
        x = node.arg
        if x[0] == '+'
          cb(s > +x)
        else if x[0] == '-'
          cb(s < -x)
        else
          cb(s == +x)
    when '-type'
      return fs.stat name, (err, stat) ->
        if node.arg == 'f'
          v = stat.isFile()
        if node.arg == 'd'
          v = stat.isDirectory()
        return cb v
    when '-a'
      return evalExpression name, environment, node.arg[0], (res) ->
        if not res
          cb res
        else
          evalExpression name, environment, node.arg[1], cb
    when '-o'
      return evalExpression name, environment, node.arg[0], (res) ->
        if res
          cb res
        else
          evalExpression name, environment, node.arg[1], cb
  console.warn "Unknown expression", node
  return cb()

# Not really a compiler, but there are some source to source
# transformations we do to add an implicit -print.
compileExpression = (expression) ->
  if expression.length == 0
    expression.push '-print'
  if '-print' not in expression and '-exec' not in expression and '-ok' not in expression
    expression = ['('].concat expression, [')', '-print']
  [parsed, tail] = parseExpression expression
  if /parse/.test process.env.FIND_DEBUG
    console.warn util.inspect parsed, depth: Infinity
  return { environment:{}, tree: parsed }

# operator precedence table
PREC =
  o: 4
  a: 8

parsePrec = (expression, precedence) ->
  if /descent/.test process.env.FIND_DEBUG
    console.warn expression
  if expression[0] == '('
    [L, tail] = parseExpression expression[1..]
    if tail[0] != ')'
      throw 'mismatched paren ' + expression + tail
    tail.shift()
  else if expression[0] in ['-name', '-path', '-perm',
    '-type', '-links', '-user', '-group',
    '-size', '-atime', '-ctime', '-mtime',
    '-newer']
    # All the 1-ary operators.
    L = { op: expression[0], arg: expression[1] }
    tail = expression[2..]
  else if expression[0] in ['-nouser', '-nogroup',
    '-xdev', '-prune', '-print', '-depth']
    # All the 0-ary operators.
    L = { op: expression[0] }
    tail = expression[1..]
  reduceTail L, tail, precedence

reduceTail = (L, tail, precedence) ->
  if tail.length == 0
    return [L, tail]
  if tail[0] == ')'
    return [L, tail]
  if tail[0] == '-o'
    if precedence <= PREC.o
      [R, tail] = parsePrec tail[1..], PREC.o
      node = { op: '-o', arg: [L, R] }
      return reduceTail node, tail, precedence
    else
      return [L, tail]
  if tail[0] == '-a'
    # -a is optional between expressions.
    tail = tail[1..]
  if precedence <= PREC.a
    [R, tail] = parsePrec tail, PREC.a
    node = { op: '-a', arg: [L, R] }
    return reduceTail node, tail, precedence
  else
    return [L, tail]

parseExpression = (exp) ->
  parsePrec exp, 0
  

one = (name, expression, cb) ->
  evalExpression name, expression.environment, expression.tree, ->
    fs.stat name, (err, st) ->
      if err
        throw err
      if st.isDirectory()
        mapdir name, expression, cb
      else
        cb()

mapdir = (dir, expression, done) ->
  fs.readdir dir, (err, names) ->
    if err
      throw err
    async.each names, (name, cb) ->
      newname = pathjoin dir, name
      one "#{newname}", expression, cb
    , done

pathjoin = (dir, name) ->
  if /\/$/.test dir
    return dir + name
  else
    return dir + "/" + name

parseArguments = (args) ->
  files = []
  expression = []
  for v,i in args
    # The first argument that is '!' or ')' or starts with a '-'
    # marks the start of the expression.
    if /^(-|!$|\($)/.test v
      expression = args[i..]
      break
    else
      files.push v
  return [files, expression]

[files, expression] = parseArguments process.argv[2..]

compiled = compileExpression expression

async.each files, (name, cb) ->
  one name, compiled, cb
, process.exit
